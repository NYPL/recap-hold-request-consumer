class Kms
  require 'rubygems'
  require 'aws-sdk'
  require 'pp'
  require 'base64'
  require 'gibberish'
  require 'json'

  attr_accessor :datakey, :ciphertext

  def decrypt
    kms = Aws::KMS::Client.new(region: 'us-east-1')
    datakey = Base64.strict_decode64(datakey)

    cleartextkey = kms.decrypt(ciphertext_blob: datakey,
                            encryption_context: { 'KeyType' => 'Some descriptive text here' })

    cipher = Gibberish::AES.new(cleartextkey.plaintext)
    cleartext = cipher.decrypt(ciphertext)
    puts cleartext
  end

  def encrypt
    # This uses the envelope-encryption model. The cleartext is not sent to AWS KMS, rather an encryption key is generated by KMS and stored alongside the ciphertext.
    # keyid looks like 6d83e627-bf08-1111-9999-23b0a0df19b1
    keyid = 'arn:aws:kms:us-east-1:224280085904:key/786b89fc-439e-42c7-ac7c-f757a3816146'
    validatorkey = IO.read(ARGV[0])

    kms = Aws::KMS::Client.new(region: 'us-east-1')

    # Encryption_context can be thought of as part of the key; it must match on both the encrypt and decrypt end.
    resp = kms.generate_data_key(
      key_id: keyid,
      encryption_context: { 'KeyType' => 'Some descriptive text here' },
      key_spec: 'AES_256'
    )
    cipher = Gibberish::AES.new(resp[:plaintext])

    outputhash = { 'ciphertext' => cipher.encrypt(validatorkey), 'datakey' => Base64.strict_encode64(resp.ciphertext_blob) }
    puts JSON.pretty_generate(outputhash)
  end
end